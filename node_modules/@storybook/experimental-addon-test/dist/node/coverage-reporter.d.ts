import { Vitest, TestSpecification, TestProject, WorkspaceProject, ResolvedCoverageOptions } from 'vitest/node';
import { ReportBase, Visitor, ReportNode } from 'istanbul-lib-report';
import { Channel } from 'storybook/internal/channels';
import { TestingModuleRunRequestPayload, TestingModuleCancelTestRunRequestPayload, TestingModuleProgressReportPayload } from 'storybook/internal/core-events';
import { experimental_UniversalStore } from 'storybook/internal/core-server';

type StoreState = {
    config: {
        coverage: boolean;
        a11y: boolean;
    };
    watching: boolean;
};

declare class VitestManager {
    private testManager;
    vitest: Vitest | null;
    vitestStartupCounter: number;
    vitestRestartPromise: Promise<void> | null;
    storyCountForCurrentRun: number;
    runningPromise: Promise<any> | null;
    isCancelling: boolean;
    constructor(testManager: TestManager);
    startVitest({ coverage }?: {
        coverage?: boolean | undefined;
    }): Promise<void>;
    restartVitest({ coverage }: {
        coverage: boolean;
    }): Promise<void>;
    private setGlobalTestNamePattern;
    private resetGlobalTestNamePattern;
    private updateLastChanged;
    private fetchStories;
    private filterStories;
    private get vite();
    runFiles(specifications: TestSpecification[], allTestsRun?: boolean): Promise<void>;
    runTests(requestPayload: TestingModuleRunRequestPayload): Promise<void>;
    cancelCurrentRun(): Promise<void>;
    closeVitest(): Promise<void>;
    getStorybookTestSpecs(): Promise<TestSpecification[]>;
    private getTestDependencies;
    runAffectedTests(trigger: string): Promise<void>;
    runAffectedTestsAfterChange(file: string): Promise<void>;
    registerVitestConfigListener(): Promise<void>;
    setupWatchers(): Promise<void>;
    isStorybookProject(project: TestProject | WorkspaceProject): boolean;
}

declare class TestManager {
    private channel;
    store: experimental_UniversalStore<StoreState>;
    private options;
    vitestManager: VitestManager;
    selectedStoryCountForLastRun: number;
    constructor(channel: Channel, store: experimental_UniversalStore<StoreState>, options?: {
        onError?: (message: string, error: Error) => void;
        onReady?: () => void;
    });
    handleConfigChange(config: StoreState['config'], previousConfig: StoreState['config']): Promise<void>;
    handleWatchModeRequest(watching: boolean): Promise<void>;
    handleRunRequest(payload: TestingModuleRunRequestPayload): Promise<void>;
    handleCancelRequest(payload: TestingModuleCancelTestRunRequestPayload): Promise<void>;
    sendProgressReport(payload: TestingModuleProgressReportPayload): Promise<void>;
    reportFatalError(message: string, error: Error | any): Promise<void>;
    static start(channel: Channel, store: experimental_UniversalStore<StoreState>, options?: typeof TestManager.prototype.options): Promise<TestManager>;
}

type StorybookCoverageReporterOptions = {
    testManager: TestManager;
    coverageOptions: ResolvedCoverageOptions<'v8'> | undefined;
};
declare class StorybookCoverageReporter extends ReportBase implements Partial<Visitor> {
    #private;
    constructor(opts: StorybookCoverageReporterOptions);
    onSummary(node: ReportNode): void;
}

export { StorybookCoverageReporterOptions, StorybookCoverageReporter as default };
